# **Reorganize the in-class lesson notes from live video_20190614**



大家pull一下今天的讲义，然后我们开始，今天讲这个线性代数，明天讲数据统计，明天讲另外一个作业，向量的概念大家其实都，又有方向，又有矢量，向量就是这样定义的。好，这个画出来了，这是向量，然后，这里我们用了一些画图的功能，就是上节课讲的这些，这个画图的函数大家好好研究下，一会我们会仔细的讲一讲这个函数，这个函数是干什么的？对，画箭头的，然后他这个画箭头的函数参数有点奇怪，我们画多的时候你会发现有意思的地方。是这样的，你要画出一个向量来，你要有起点，要有终点，终点其实就是我们定义的这个值，终点是2,1，起点是0,0，然后定义很怪的，这样的东西，一会我们就可以看到，然后，我们计算这个，所谓向量是指有值和有方向的量，我们怎么计算它的大小？其实这是一个很直观的定义，就是如果我们把刚才那个公式直接用数学的平方，然后开方算一下的话，跟刚才那个值应该差不多的，然后，他正式的定义是这个样子的，在一个n维空间的情况，这是什么？这是如果我们向量是什么意思，比方说，它有x，y，z，很多很多维度，但是一个矩阵你怎么去算它大小，比方说一个矩阵，它可能不是一个二维的，它是一个2×2的，他有4个数你怎么去算他的大小，矩阵的定义是这个样子的，大家注意一下这个下标，其实就是把每个数值都平方，然后加起来，再开方，那对于矩阵，它还有个一个专门的方法就是norm，就是算这个标量的方法，我们刚才那个其实是不是特别有通用性，就是我们自己用的东西。正确的做法应该是这个样子的，然后大家可以看一下就是这个东西的定义，你们可以自己滚动一下看看这个function它。它比较有意思的地方是什么，我们往下看，就是你看，他首先分有两类，我们刚才也提到这个问题，对矩阵，对向量，我们看对向量，其实不光是我们最熟悉的地方，求什么平方根，还有这种，求最大值，求最小值，所以，有的时候我们怎么求一个比方说一个矩阵的所有元素的最小值，他其实用这个函数可以算出来，然后你写这个参数的时候你要写上这个奇怪的地方，无穷大。大家要注意，求最大值，最小值的时候是由按照什么什么轴来求的，你看这里他有一个reshape的操作，它变成了一个3x3的矩阵。然后这个3x3的矩阵直接算平方。计算向量的方向，就是为什么用tan来算这个角度，这样因为简单，但是我们要注意我们算角度的时候其实有2种角度，就是弧度，我们熟悉的角度，大家注意一下这个问题。然后在数学上，其实你算出来缺什么的并不是我们平常说的度，可以看一下我写的注释，算出来的是弧度值，这是y，x，它两一除，，tan，求出来应该是一个弧度，我们再把它转换成角度，这个操作其实普通的计算机上都有的，你计算器点一点就能算出这个角度来，然后我们刚才介绍的向量，知道怎么算它这个标量，算这个向量的角度，或者是一个象限的问题。然后介绍了向量的最基本的特性以后，我们来研究一下向量的运算向量的加，很简单，两个向量，我们把这两个向量画出来，2跟1是这个红色的，-3和2是这个蓝色的，大家想象一下他俩加了以后，这个向量应该是出现在什么地方？在物理上对应的是什么？物理上对应的是分力和合力，就是两个分力加起来的合力，一个合力可以分解成两个分力，所以我们继续往下看，再画图的话，家的规则就是一一对应的加起来，他符合我们的直觉，画出来是这个绿的，大家其实可以脑补一下，就是差不多是一个平行四边形的样子，就是你回一下你初中或者高中物理，想起来这个例子，向量乘，说完加我们来说乘，然后，这个乘呢，有3种，然后，我们可能讲的比较多的是后两种，因为前面这个乘就是乘以一个数，就是它的几何含义就是沿着原来的方向伸长或者缩短，乘一个数就是直接乘一下，大家很好理解，大概就是这个样子，原来是在这里，我们扩大了一倍，除也是一样的，我们把它缩小了一倍，点积，还记得在numpy里面做的点积的函数叫什么来着，dot。然后它有个简写，有印象吗，@，然后他的做法也很简单，对应数相乘然后加起来，大家想一下，点积这个东西呢干什么，它在物理上或者在几何上它的含义是什么？就是这里有两个向量，然后，我们做一下点积的目的是干什么？或者是它有什么含义？大家发现了吗？他其实算出来是一个数，他算出来不是一个向量，它是一个值。那如果这个值是0代表什么，对，代表垂直，没关系，他完全没有正交的样子，那如果算出来是1什么概念？完全是一样的。不一定一样的。我们看一下，复习一下它的方法名或者直接操作，注意一下，在numpy里面，就是这些操作，后面我们也会看到，比方说，你可以拿一个向量去乘一个矩阵，然后你也可以拿两个矩阵去乘，但是你要注意就是，你一定要知道他两边的东西是什么，你脑子里面一定要有他们的情况，你要是不确定他们是什么样子，你就打出来看看，你画一画，这个玩意儿是经常搞错的，就是从数学上来说，你可以用点积来做他的cosin，就是通过点积算出一个数来，这个东西我们已经知道怎么算它的数值，这个也知道标量，所以把这个点积除以标量的积，最后应该是一个COS的值，所以如果他是0的话，就代表他的delta应该是90度，这两个向量我们刚才还记得吗？就是那个平行四边形，他俩的夹角差不多是120度，算出来。然后我们把这个公式重复一遍，上面是我们刚刚学的，求这个标量，这个COS的值就是点积除以这个标量的积，然后算出来应该是一个弧度值，然后我们再转换一下，物理含义，只要记住这一点，他其实如果不是从物理上来解释，两个向量其实是代表现实世界的两个事件，代表什么意思呢，他们的相关性，它们有多大的关联，这个比较不一样，叉积，或者说外积，他的做法就是试这样的，叉积出来以后还是一个向量，p和q叉出来以后还是一个向量，然后怎么算r的3个量呢，比方说，第一个就是除了它之外的2个，这样p加rq3减去p3，q2，第2个就是这样的，第3个就是这样子，这个听起来很boring，你为什么要穿这个玩意儿？干嘛用的？谁还能回忆起来这是干嘛用的？旋转有关，也不能说和旋转有关，大家还记得那个右手法则吗？右手法则就是，比方说我有一个电场，有一个线圈，有一个电流，会有一个磁场，这样，磁场应该有方向，就这个原理，你怎么来想象这件事情？你把你的手相第1个向量的方向，拇指指的方向，还有不一定是磁场，你也可以用这个东西来算，比方说光线，就是我们画一个曲面，而这个局面可能是一个球形，然后我们想知道这个点的方向，这是任意的一个曲线，这里有一个方向，然后这里有一个方向，然后我们把这两个点用同样的规则，可以做叉乘，就是这个点这个面的方向，向量，比方说你在这个面上找两个正交线，x和y的向量，他俩可能成一个角度，算出来的第3个应该是跟这个垂直的，做这个东西干什么？用比方说我想，把一个光线在上面，这个光线是多少？就用这个公式来算，然后你就记住这个名字叫dot，这个叫cross，这个数出来以后就说我们刚才那个数没有简写的方式，然后我们来写个代码，把这个东西可视化一下。



然后我们来写个代码，把这个东西可视化一下。就是理解一下cross，是咋回事，这是代码的第一部分，我写了一些help，以后我们会再回过头来看这一段代码，大家知道只是一些function，然后，这个代码比较怪异，你们可以试试，插件不是很稳定，有的时候用不出来。然后以前我们看到的那些就是一个图片，但是现在不一样了，现在是可以操作的，你看，是吧，这个紫色和黄色的线，这个空间的关系大家能看出来的吧？他们角度的关系，就是这个样子的，然后为了把这个东西画出来，讲这个概念到这里就够了，我们就是讲一下什么是叉积，叉出来的积也是一个向量，但是，为了把这个玩意画出来，就有搞这个东西，我们来看看这个代码，这些代码其实就是在这里，web，3d，其实就是一些帮助函数，我们调了他的这个部分，这是它的一个功能，但在jupyter里面，就是如果你想搞出一个三维的东西来，你要装一些JS的东西，我已经把它弄在doctor里面了，然后给这些代码新加了一些注释，你看这种风格的注释，你先python的document的时候，你写的下面这个叫documents，python的document格式很像Java的document格式，你通常看到的是一个参数列表，然后第1个参数，第2个参数第三，参数然后返回值是什么？通常你用一个函数的时候，你其实最关心这些东西，你把它当成一个黑盒，你输入什么输出什么，然后，你只要输入和输出的类型，不要搞错了，至少你的亮光是对的，这种定义的风格，其实不是Python这种语言常见的，有一些编程语言你在定义函数的时候，你就写成这个样子了，类似这样子的，就是这是一个参数的表，这是一个返回值，然后这里面用了很多list，我们好像讲过这个东西，一个list里面有for循环，变成另外一个list，我记得在讲python的时候讲过，但是没有讲这么复杂的，比方说你看下面这个公式，就是for里面又有一个for。然后，是要干什么？大家知道读这种代码最好的方法是什么？就是如果读这个document，你会知道这里有ABC三个，然后这三个vector算出来是什么呢？这是他们所有x的最大值，最小值，算这个东西干嘛用的？但这个东西其实是要把这个三维图形绘图的空间给固定住，就是你要知道所有的这些点出现在什么范围里面，然后把这些当成一个参数给后面的函数用，这是干嘛用的？这个就是做标记，就是说，我这个地方画了一个点，然后这个点的值是多少？在三维空间里面，他跟二维不一样，二维很明显能看到有多远，有多大，有多高，但在三维里面他一转，他有透视，所以你很难看出来它这个东西到底有多大，我们需要有一个值把它标示出来，当然就是如果我们，你也可以这样，差不多是一个意思，但是你不能总是这样，其实他俩差的挺多的，一个是-2，一个是负8，-2在这里负8在这里，不是很容易识别出来的，所以要有一个标注，这个其实是给画箭头的一个东西一个坐标，因为我们刚才讲到你画一个向量的时候，不能只给一个向量的点的坐标，你要告诉他起点在哪里，你看这里边也是先搞一个，把它跟原来的向量加起来，大家可以自己跑一下，比方说你搞一个，你就调用一下这个函数，我们下面应该有一段代码，在这里这里有一个，然后，我们改一下。你看他其实搞出来的是6个坐标点，就是三维的点，这就是三个x这是三个y，大家可以自己试一下，都是在干什么？这是一种读代码的方式，有时候你要直接看，有时候你直接看不是太懂，比方说这个我们有公式了，我们看的不是太清楚，就是你看颜色，其实跟坐标没有什么关系，就是我选三个颜色，为什么我要搞的这么复杂？因为我们不能把他固定写出来，我们选三个不一样的颜色是可以的，选三个不一样的颜色，最后出来的是一个这样的数字，颜色一，颜色二，颜色三，然后两个颜色，一两个颜色，二两个颜色噻，他的意思就是你画一个，他画的顺序是这样子的，画三个向量，他先画三个向量的线，然后他在画这个，所以你要把它的颜色先定好，其实我们这些所谓的help的function，只是一些我们，因为他的输入很简单，我们就要把它弄成适合后面function调用的样子，但是这里面就有可能有点怪异，不是太看得懂，比方说这个，什么意思？把他们自己和自己zip了一下，展开，然后把原来的rgb加上，其实，说白了就是凑出一个东西，你不这样写，你硬写一个东西也是可以的。为什么要把这个东西写成这个样子这个样子？这个函数很短，差不多这些函数里面他们都是一行这样子，一行这样子的表达式，然后这个表达式通常会依赖于外部的参数，外部的参数是跟这个表达式里面的没有关系的，一旦把一个函数写成这个样子，它的坏处就是在某种程度上他不是太容易读，他不是能一目了然的看出来他是在干什么的，但是一般表达式类型的东西，你把这个表达式给他调好了，这里面没有很多逻辑，没有很多边界，没有很多行说白了，他差不多和一个正则一样，他对就是对，错就是错，不可能存在这种情况下，对这种情况下错，所以就可以保证这些能长期的运行，这是一种你做软件的方式，我们做明天练习的时候也会用到类似的方法，这一部分的代码我觉得大家可以看一下，他其实只是跟这个画这个图相关，画是这些图需要这些帮助函数，所以搞了这4个函数，这里面用了同样的办法，基本上就是反反复复用这些，目的就是提供一套接口，就是我们写代码的时候能写这种东西，就是有的时候你想了解接口，我们写一个document string，它是一个文档，你可以知道很多概念，但是你想知道这个代码在干什么？最简单的办法就是你跑一下，然后你看得越多跑的越多，你就可以直接通过阅读，也能够理解他，就可以用自己的脑子去运行这个代码，然后我们讲这个向量，我们然后我们来讲这个矩阵，然后在这个numpy里面，有一个专门的函数，叫matrix，matrix是array的一个字类，array可以matrix也可以，我来找一下matrix有什么神奇的地方？矩阵加，这是我们刚才研究向量的时候有一个向量对应的标量，给了矩阵的一个标量，他其实是应该放在这个地方，但是矩阵这个东西和不一样的地方是，他没有一个方向的概念，不像向量一样有一个指向性，但是他也有类似4则运算的东西，我们验证一下，然后，还有一个简写的符号，可以直接写成加号，有加就有减，都差不多，大家休息一下。



求负，你搞个全屏矩阵减一减也是一样的，转置，transpose，简写，注意简写，我看到有些同学在代码里也在用这些，矩阵乘以标量，所有的都扩大一倍，我们讲一下矩阵乘，矩阵乘比较重要，大家都能想起来矩阵成是怎么一回事吧，写了一个比较啰嗦的，你们看一下，什么意思呢？就是，一个2×3×3×2的矩阵，盛出来以后应该是一个2×2的矩阵，然后他们是以对应的数相乘，然后再加起来，算出来是第1个位置，以此类推，这一行这一列算出来的是他，这是乘的过程，规模大的也是这个样子，然后我们用代码来做一遍，矩阵乘就跟向量的dot，有点混，你们两个向量dot以后是一个值，但你矩阵dot以后不是一个值，他是另一个矩阵，然后还有一点大家需要注意的地方是，这个乘是有顺序的，注意一下，你看dot a，a在前面b乘出来的是这个，但是如果你把它反过来，写成b×a，乘出来就是一个3×3的矩阵，然后，我们回到这里用脑子想一下这个，需要把它转一下，就是这个矩阵在前面了，看的有点别扭，但是你想象一下，最后乘出来的一个矩阵，然后我们比较一下这些操作，学了很多矩阵向量乘积，dot，符号，对于两个矩阵来说，这两个加你也可以直接写一个乘号，但是，向量不能直接写一个add的符号了。我来把它改一下，这里是可以的，dot其实对应的是这个东西，两个向量的dot，这是一个向量，line是一个向量，column是一个向量，他乘出来应该是一个数，就这个。如果你apply这个东西，我们刚才讲过向量加，我们只讲了向量有三种乘，成交量，点积，叉积，这个东西好像我们没有讲过，这就是这两个向量，其实是一样的，所以，对于向量来说，这两不是等价的，在数学上也很少这样去做，向量对应乘一下，没什么意义的，没有人这么干过，但这个是有必要做的他有几何意义的，对矩阵来讲足够了，我们这个注释里面写了一大堆东西是为了highlight向量的另外一个含义。你看这个符号，一会是@符号，一会是乘号，然后这个左一边右一边，有的时候可能两边都是向量，两边都是矩阵，有可能一边是向量，一边是矩阵，和顺序有关系，要多练习。然后我们再来试一试，把一个向量去乘上一个矩阵，第一个是可以乘的，写出来是这个样子。矩阵相乘没有交换律，其实我们刚才已经试过这个了，两个2×3矩阵，乘出来他俩的维度是不一样的，一个是2×2的，一个是3×3的，这也是一个，乘的结果也是不一样的，大家可以自己敲代码，敲出来看看乘出来是不是一样，我下面有代码，大家可以自己搞一下练习练习，验证它不一样，这个的意思就是说，我们学的这个自然数的乘法，其实这是对的，不管怎么乘都是一样的，但这个是不成立的，他俩没有交换律，因为它有维度的原因，我们看看最后算出来的结果，他讲这个撑起来的维度是没有变化的，但是值不一样，看完全不一样。其实我们刚才做了两个变化，换了一下等于是一个镜像。比方说我们把操作反过来，我们先把它镜像，然后再放大，我们先放大再镜像，会出现和这个一模一样的图形吗？对，会吗？后面我们会讲这个东西叫仿射变换，本来我想讲这个，但是后来想想算了，我们就讲线性代数，讲到这个变化，我们首先想到的是有一种变化等于不变，就是乘以一个单位矩阵等于什么都不做，单位矩阵就是这样，在对角线乘以1的矩阵。逆矩阵就是我们刚才讲的矩阵加矩阵乘，然后逆矩阵就可以把它理解成矩阵除，就像一个数乘以它的倒数为1，就是矩阵乘以它的逆矩阵就是单位矩阵是一样的，就是我们刚才已经试过了，这两个是一样的，我们可以交换它，矩阵求逆有一个调用，我们其实在讲numpy的时候就举过这个例子，就是做这个东西，还有个简写，就是大写的t和大写的i，它的是逆矩阵什么？大家算一算，其实就是把他的这些诉求一个倒数，这是求逆矩阵的时候，有时候你会碰见一些比较奇怪的情况，你会算出来一些好像特别小的数，非常非常小，其实它应该是等于0，一会我们验证的时候就会讲到这一点，你需要注意一下，这里面有一个误差的问题，就是你想除法有一个除不尽的问题，求矩阵也会碰到类似的问题，这还好，这个可以正好整除，逆矩阵能干什么？可以用来解方程组，我们其实以前讲过这个例子，我们把一个方程组看成是一个矩阵，自变量向量的积，我们就可以把这个方程组写成ax和b的形式，然后我们解这个方程组，如果你两边都乘以一个逆矩阵的话，a乘以a的逆矩阵就是单位矩阵，就消掉了，所以左边只剩下x，右边就是逆矩阵乘以b，最后我们乘起来算出一个结果，把5和2代进去是对的，大家可以验证一下，我们用数学过程来验证一下。



就是这种形式比较好懂，其实上面这个更像我们写的数学公式，就是你看一个数学符号你也能够明白，就是我们读代码有两种倾向，或者是语言的设计，我们写代码的风格，我们尽量像自然语言，就像我们在说一样，我觉得这里面最突出的一个例子就是，这个苹果上面有一个脚本语言叫做，apple string这个东西写的就是很啰嗦，完全就是一大堆英语单词，还有一些程序语言，就根本不是这个风格的，像符号语言一样，像数学公式一样，那么，显而易见的是象自然语言的这种程序语言，或者说表达方式，它的好处显而易见的，我就是我不是太明白，但是我懂自然语言，我也能看懂，这种写法的好处就不那么明显，就是你必须要记这些东西，但是短有特别大的好处，这是短的好处是什么？短的好处就是，意味着在一个很有限的空间里面，就可以抓住很多information，然后你不用上下左右去移动你的目光，也不用去找，因为如果你一旦开始这样写，那么我的问题就来了，这个n我不知道是什么意思，什么叫MP？还有你这个东西是什么简写？他这个意思是线性代数与算法，然后这个a没有说明，如果你把这个东西都补全的话，他就有可能很长，然后你就会发现这个不行，这个太长了，我们得把它分成好多好，然后后来发现分成好多行业不够用，因为屏幕就那么大，你打印不了多少行，然后你就有很多文件夹，很多类，然后很多命名规则你会发现有很多，然后你就会觉得你什么都没有说，但是很长，就读不懂了，这就是他的问题，我们以后可以看看完全两种不同的风格，我讲一点这个有点深度的东西，变换特征向量和特征值，大家还记得以前跟大家说过查那个文档的时候，就是有些文档你能猜出来，比方说求逆，然后乘，点积。但有些事你猜不出来，除非你知道他，否则你输入什么number，你是找不到他的，这是翻译带来的问题，我们先来看这个线性变化，我觉得这个其实写的不是很好，这个只是说了什么是变换？没说什么是线性变换，线性变换的含义是什么？这个变换有两个特点，我们第1个变换比方说，我们用一个函数来代表，不一定是向量和线性代数，什么叫一个线性的变化？就是说，你可以乘出来一个这样的东西，这是一种特性，比方说a是一个常数，我可以x×以一个常数等于它，还有一个特征就是这样子，我们回到这个变换上来，被变化的目标是这个向量，我们用另一种方式，我们刚才讲的乘，解方程，现在我们把这些具体的问题都抛在一边，我们只是抽象的来理解他，说他没变换，你可以把它想象成，你把它做某种操作，最常见的操作比方说，刚才我们做的平移，加一个常数，然后，说话其实就是乘一个常数，然后就旋转就是加成，角度，我们把这些变化累积起来，就是变化为1，然后再变换在变换，其实就是相当于或者等价于，我们乘矩阵再乘矩阵，然后我们就把所有的这种在不同空间向量，这些复杂的操作都变成了数学，可以计算的，因为我们会算矩阵乘，徐正成他最简单的定义就是，可以做加乘，然后我们也能算它的逆运算，所谓的矩阵求逆，然后我们在这个角度再来看一下就是，这些向量的变化，它有什么几何或者物理含义？这个就是把刚才的重复一遍，比如说这个它就是变成一个三维的，我们刚才看的都是在二维空间里面比较容易的，在几何上可视化的，他其实可以是这个样子的，就他就是变换了他的维度，我们刚才也讲过缩放，举过了例子，把它变大就是10变成了20，这就是一个缩放变化，这是一个旋转90度的变化，有一个公式旋转90度。还有一个平移我们没有讲，平移其实就是加一个数，我们可以把这个东西定义为看一看，这两个地方是COS，反正是一个30度的角，是一个tan30度的角，用旋转的这个几何定义，我们现在只是说它这个东西有旋转的效果，我们一乘，这是多少度我们也不知道，我想知道就是我给你一个度数，你给我算他之后的坐标，比方说我们给三个角度，阿尔法贝塔伽玛，其实我return的是一个变换矩阵，就是用这个方法构造的，但这个东西是不是很高效？我们接下来看特征向量和特征值，特征向量和特征值的定义，我们为什么要搞这个东西？就是我们想简化，想简化这个问题，这是我们现在看见一个很大的矩阵，有很多数据，然后我们想把他降为成一些向量，一些值，至少没有那么多数了，我们通过这些向量的值，也能比方说算出求解方程组，这样的运算，所以在整个这样的过程当中，我们的信息并没有丢失，而且通过做这种特殊的分析的话，还可以把两种看起来不太一样的东西给关联起来，比方说两个矩阵可能一开始看上去，看起来不太一样，但是它们在特征空间里面是一个东西，就好像有两个不同的方程组你算出来，他们的解是一样的，就是xyz的值，他们是一样的，一看就是这个东西，我们刚才讲过这个伸缩的时候，这是一个单位矩阵乘以2，这是一个向量，他的意思是x是1，一个这样的向量，然后我们把它放大一倍，你不用看他数学上的这些计算，第1种变化就是我做一种变化，第2个就是我乘以2，他俩是等价的，然后你就会发现他4个字变成了一个值，这就是这个基本的想法，就是其实我们比方说坐后面的学习机器学习的时候，就是你把一个问题尽可能的把它给映射到一个特征，各种各样的参数来表示空间的排序，然后你在那个空间里面求解，因为你没法在原来的巨大的数据上求解，比方说你要做各种各样的转换，比方说人脸识别，照一个照片像素有几千万个，但是最终你根据这个，人脸固有的特征，如果角度是正对的话，它应该是一个对称的，这些五官的分布都是有规定的，还是有一些固定的点，比方说眼角的位置，嘴角的位置，鼻子的位置，这些东西化妆是很难把它改掉的，你可以改变颜色，但是这些几何特征你是改变不了的，我们就是把这些特征抽出来，你会发现你并不是在原始的数据上面操作，你都是在一些特征上面去做操作，做自然语言处理，自然语言原始的信息是非常大，我们怎么把它变成一个像这样的东西？变成一个向量变成一个矩阵，我们好在上面做各种各样的数学运算，基本的想法是这个样子的，我们看一下这个文档，现在break一下，吃饭。



开始，这个就是这个文档，看这个文档其实最主要的是这个东西，就是有2个返回值，前面这个是特征值，2个然后特征向量，就是这个你要注意他们对应关系。这个比较整齐的例子，对，还是刚才那个，然后，我们把它分成2对，大家可以验证一下，就是这个什么意思呢，就是这不是成对出现的嘛，他两乘就是这个，跟这个矩阵直接乘以特征向量得的结果是一样的，在某种程度上，简化了这个问题，大家自己求一下，写点code，这是一个matrix。就是线性代数这些，这个部分其实code都很简单，就调一调就完了就是题也不是太好出，它的起源本来就是一个机器计算问题，然后，而且这个问题已经被研究的非常深入了，库都是现成的也不需要你去实现这个库，你知道这些概念，你去用这些函数，他就可以算出来，其实就是调用一下这个东西，其实就是把这一段抄一遍，自己看结果是什么，你一看这个你就知道有一个特征向量，一定是2.反正大家求出来是这个值。然后我们来验证一下刚才的那个等式，特征值乘以特征向量。他应该等于矩阵，乘以特征向量，然后把它写出来大概就是这个样子，对，其实你用眼睛看你大概算一下你就能算出来，3对应的是下面的向量，就是你看结果出来以后你要这样看，这个是3是吧，它对应的特征向量是这个，这个是1，它对应的是这个，你看他取值的时候，它其实取得是第一列，这一列，那个返回的结果就是这样子，大家注意一下不要以为这个是它的特征向量，然后它是这样排列的，然后，2个正的。就很显然，他乘他就还是它。然后这是一个变换，这个，其实这个q啊其实就是这里面的q它就是特征向量，就成了一个矩阵。这个q就是一个特征向量组成的矩阵，这个是特征值组成的一个对角阵，就是对角线上的一个值，比方说，单位矩阵就是对角线上都是1的对角阵，然后，后面是它的逆矩阵，你怎么来想象，想象他数学上的含义，就是，你通过乘一个特征向量的矩阵。然后把它投影到特征值得空间上，然后，apply一个特征值，然后再把它扭回来，就是这样，搞到一个地方去操作，然后再逆操作回来，这样的话你就把给分解成3个矩阵的积，因为，我们刚才知道你看这个document的时候他说你给我的a是一个方阵，我给你的特征值和特征向量都是成对出现的，所以就是说如果有3个特征值，就应该有3个特征向量，你们，大家想象一下这个把a分解了以后它就会变成这个现状的东西，我们不管它是什么样的，我们把他画成一个方形的东西，然后，这后面是它的逆，然后，就这种矩阵我们很喜欢因为它很简单，很好操作，这种矩阵也非常好，我们也很喜欢因为它有逆矩阵，我们看一下，比方说，这里有一个方阵，3,2,1,0，我们求它的特征值和特征向量，然后我们用这个小写的l来代表。他其实就是他的向量里面都是他的值，然后用这个q来代表特征向量一组，比方说，你有5个，对这个来说有2个特征值，然后这里还有个大写的L，就把a分解成这样的东西，就根据我们刚才的公式，我们要证明a就等于3个量相乘。然后，其实还差一个q的逆矩阵，我们可以写成这类的东西。那么，按照刚才的这个公式，是不是这3个公式相乘就得到它呢。其实你看，很多东西它长的形式差异很大，但是他基本的思路是一样的，比方说我们上节课讲的多项式分解，把函数分解成基数的形式，为什么我们要把它分解成基数的形式，因为基数就是多项式。为什么要分解多项式呢，因为首先，对于多项式里面的每一项我们知道怎么求导，他的特效我们非常熟悉，然后，另外一个就是一旦把它分解了以后，我们就可以做很多组合，做简化，同样的思路，我们也可以用在这，我们怎么把一个矩阵拆开来，我们拆成矩阵的乘积，这里有个非常常用的拆法，矩阵的乘积你有各种各样的组合，我为什么要这样做，因为它里面是有含义的，我们验证一下，对，就这样3个我们列在这里，大家注意了，这个计算精度的问题，就是它里某个整数特别近的话，那些在误差范围内的就忽略掉，其实我们直接打印的话就这个样子，然后我们要这个东西，一大堆，我们想证明这2个东西是等价的。其实你眼睛一看你是知道他两是一样的，这个后面都没有它这个价值极小的数，这个数几乎为零，但是这是一个误差的。其实就是一些没什么太大意义的东西，但是如果你程序不注意这些东西，你就不知道在什么地方给带偏了，你的结论不对了，你是想验证它，大概是这个意思，我们不是有3个矩阵吗，一个特征向量矩阵，一个特征向量逆矩阵，中间有个特征值矩阵，然后我乘3个矩阵，其实就相当于把比方说我刚才就是乘以一个v是吧，这个v连续乘3个矩阵，其实就相当于某种变换的过程，变换的整体在一个空间里面，旋转啊，缩放啊，平移啊，然后我们看一下，它的顺序是这个样子的，一开始是一个黄色的，他是初始的一个向量，我们定义的这个v，然后q，整个变换的过程。这有一个矩阵的秩的概念，就是矩阵的秩其实我自己理解的意义是，你把方阵看成是一个方程组的系数矩阵，然后这个矩阵的秩是说这个系数矩阵里面到底包含了多少个特征，这个特征的数不够你这个系数的维度，这说明你的有2个方程它讲的是同一个事，它并没有提供更多的信息，你没法解它的，你的信息不够，就是说你这种方程你是解不了的。



如果他不是满秩，这些值就可以忽略，非常非常小，基本接近于0，这种非满秩的矩阵，我们把它叫做欠定矩阵。你看这个对角线上虽然有值，但他基本上是0，为什么是0？这三个都很类似，好像就是两个平行的线没有交点，，交点可以把它理解成一个解。有了这个概念，我们就来研究一下如果这是个满秩的矩阵，他就有可逆性，，意思就是说，很大的一个麻烦是，给你一个矩阵，你并不知道他是不是可逆，也不知道用什么方法来求他，现在能算他的特征值，把矩阵拆开。能不能利用这一点来算逆矩阵。如果能算出来逆矩阵，那方程的解也就能算出。一个矩阵逆矩阵根据定义，跟本身相乘是单位矩阵。然后把原来定义代进去，两边同时乘以A逆，然后化简，I是可以消掉的，就能证明，我们从特征值分解的定义出发后推导出怎么求逆矩阵这个方法，逆矩阵也有一个很复杂手算的求法。为什么要讲这种简化的东西，因为我告诉你一个问题，你可能不知道一个function的调用，你自己实现了一套，然后我告诉你有这样的一个method，很好很短，然后你就可以解决这个问题。但是在很多情况下并没有现成的function让你去calll，你要自己figure out出来一个解，你要看出来一个复杂的问题是可以简化的，是等价的。
把一个矩阵除法降为成一个算术除法，反过来证明了欠定矩阵没有逆矩阵。对于一个满秩方正，假设一个方程是有解的，解得方法就是求系数矩阵的逆矩阵，根据刚才的推导，我们只需要求出特征向量，特征值来。通常比A要简单。我们看一个例子，一个矩阵【1 2,4 3】，我们要求它的逆矩阵，首先把它做一个特征值的分解，然后用刚才的公式。



求解第一步是读这个题，然后理解这个题意思是什么，通常会有一个意向，应该怎么去弄。这个解可能不是很好，但他是一个起点，是一个启发式的解，在这个基础上能够继续深入，找到规律。看起来是个宏大的项目，其实关键点是非常少的，只有两点，可以完全用jndex操作来实现，也可以调用一些numpy的方法，但是在调用的时候，你会发现不同的策略你怎么去实现它，互相compete最后的结果，我发现所有性能高的解，他们方法都一样，在数学上是完全一样的，只是用不同的程序语言来实现，我自己还没看到过在数学上有大不同的解。基本上有两种套路，这是一个模拟生命演化的游戏，这是什么概念，从哪个地方来的，为什么要模拟。这是一个数学家提出来的，他是一个非常老的问题，但他不是平白无故提出这个问题的，它的起点可以追溯到更早，可能在60年代，在50年代对于计创新发展发展算机界的重要人物，他在考虑什么问题呢，就是地球上资源早晚是不够用的，解决方案是移民到其他星球上面去。为什么是火星，因为看起来有很多的铁元素，我们把氧化铁里面的氧释放出来就有氧气了，这个机器的目的就是复制自己，他设计了一套理论，设计了29种状态。到了60年代，他们觉得要把系统大大的简化，就两种状态，可以自我复制。他设计了很多原则，这是一个纯粹的数学游戏。他的存在有合理性，规律是相符的。规则就是三条，又很辩证的东西。但一旦引入发展的事务就比较复杂了，是个动态的过程。规则会演化成怎样我们也不知道。我们要定量的画下来。



比方说这里有个生物，周围都是邻居，如果有一个邻居会死，两个邻居会死，三个可以活。三个邻居和两个邻居有个很微妙的差别，它的下一代会生出来。这不是两个父母生一个小孩，他是三个生一个，而不是二。这个原则很简单，我们举一些例子，这样一个稳定了。他有很多pattern。我看了很多解释，这是我的理解，你想弄明白，你去看Wiki。视频里的每一黄点就代表一个生命个体，然后他们互相会应用这些规则。这就是一个应用，你会发现他的思维方式，不是形式化的，他是先举一个例子，这是一个很好的方式。里面的生死是同时发生的。现在你去看这个问题，你会感觉到你人思维的弱势，因为人的视觉是有焦点的，很难观察到全局。Glider就是爬一样，就像人类的繁衍也是迁徙的过程，前提是有足够的规模。自行演化的过程中，不管是什么configure，会不会所有的都消失？
这是冯诺依曼，我们学计算机的应该都知道他，但是我们只知道他的名字，不知道他做什么的，他很喜欢喝酒，搞一些party。



他说这个游戏发表以后，这个杂志100多年以来收到读者来信最多的一篇文章。你们可以自己试一下，下面有configure，大家可以自己玩一玩。这其实不是一个游戏，他没有交互。然后wiki这个网络能访问吗，还是只是慢一点。我们挑战一下，用python实现一个，其实你只要做一步，你就能不停得做，我们要让这个东西有点真实性，我们就搞一个100万个空间，我们前面没有讲到边界，边界这个东西不好定义的，首先要实现这些规则，我们不需要画这个图，做出来第一步，我们就可以做代码的优化，其实code也不是很长，你随便·search就会发现无数解，你看得多了就会发现有定式在里面，一会儿花一些时间看这个代码，提示的话，先跑一下再调试。



我们一起来读一下这个代码，我在这里发现有notebook。 它的代码很长，有绘画的部分，往下走有130个迭代，比较关键的是get neighbor，就是把邻居挑出来，算有多少个邻居，然后每一个点会变成一个数值，然后这个数值去决定他是生还是死，有可能一个点是0，他也有可能是生。为什么要用dictionary来存这个，一开始，每一次计数都不算，因为情况全变了，他有一个重置的操作，你们会觉得他的效率会高吗？你可以试一试他这个代码，我觉得他效率不会搞，他neighbor counts里面，这里面有两个for 循环，看他写了多少行。



除去他画图的部分也有30多行吧，这是一个其他的解，你应该能得到一个印象是这个问题的结构他可以分成两部，一步是算邻居数，第二步是apply那些规则，至少有两层循环。我们也用到这个图形，他的想法是搞了一个索引，存一个二维的数，原始的world的数已经定了，neighbor的数不可能比他多，neighbor的数一定等于world的数。100万个格子以工业就100万个neighbor。要么就是100万个dictionary，要么就是1000x1000个二位数组。我觉得数组应该比dictionary快。因为我的index的速度是1，但是dictionary的速度应该是log。如果这个东西很大，可能内存就装不下了。我们看一下display，它的规模也不是很大。再看这个，应该是比较大开眼界的。我浏览过这些代码的实现，吸引你的那些点可能是看起来很短，看起来很整洁，你会的语言应该里面都有。我觉得各个时代可能有新的计算机语言。

Fortune 它本身不是时间序列，不是一个波形.Go 也是一个很popular的语言，Haskell其实跟Fsharp 是同一类。Julia其实我们做这个在行业里也是一个主要的语言，除了python和R以外，好像最popular的就是这个，做数据运算。其实循环一个东西，其实多了以后你很难track他在做什么。这些短的就是因为有了函数，直接可以调用。



如果你用pandas，是不是你可以搞一个SQL，pandas你从一个csv读进来，你也可以把他搞进一个SQL里面，是不是还更快，更通用。然后我们看看我们提供的解，这个不算长的。两个函数算邻居，计算8个邻居，然后apply规则，也很简单，对所有点apply规则，两个for循环，然后把规则定为两类，灭亡的规则，就是太少，太多。还有就是原来3个。上面是算矩阵点，你把Z【x】[y].,大家能看到周围8个矩阵，算出来一加，用N来表示邻居。算一下，三代，一百万，算出来6秒多。你要知道虽然不要去纠结这个数，不同算法见的比例差一两个量级是固定的，这个code能看懂吗？

疑问？改了之后时间更久了，现在是两个for循环去取邻居个数，然后算出来应用规则，我把他在一个循环里面做，时间会是两倍。 实际的操作数并没有变少，无论在那个函数里面做，他俩应该是差不多的，但为什么会多一点。 应该就是差不多的。看起来有100毫秒的差，我们最后的version总共才20多毫秒，怎么来解释。基本上是6偏下，我觉得如果你把他的放在一个for循环里面，这段code他在Z去取值，把他写道N里，下面也是N里取往Z里面写。他的memory access的pattern会导致有一些数据被编译后，没法证明。并没有消减，我们知道这100万个循环是省不掉的，因为无论如何每个点都要算一遍，然后没一个点的计算量，加法和判断都是10规模，那整个就是1000万·个，看起来没法省了，我给大家一些提示。

我们用numpy，我们学了就去用。跟list不一样，list你也不知道有多少个list，他在内存里分布的零零碎碎的，导致他们的性能完全不一样。一个提示是去掉邻居数循环。Argware意思就是把数组拽长了，变成一个很长的一维的东西，就有index。 用numpy抽象的程度就上来了，是一个vector,是整个矩阵，是一个很好的启发性的东西。

APL这个代码不是一行一行的看，是一个字符一个字符得看，每一个点都很重要。他有另外一种好懂的方式，这个语言的特点是没有括号，没有for，没有各种分支，没有循环，没有运算优先级，没有block，读的顺序是从右边开始。这个意思就是说这个符号叫rotage, 意思就是旋转矩阵，他想干嘛？他想搞一个大的矩阵，一下子算邻居和，有一个video我们明天可以看一看。